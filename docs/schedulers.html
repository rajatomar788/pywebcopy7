<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pywebcopy.schedulers API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pywebcopy.schedulers</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2020; Raja Tomar
# See license for more details
import logging
import threading
import weakref

from requests import ConnectionError
from six import PY3
from six import string_types
from six.moves.urllib.parse import urlparse

from .elements import VoidResource
from .elements import CSSResource
from .elements import JSResource
from .elements import AbsoluteUrlResource
from .elements import GenericResource
from .elements import HTMLResource
from .elements import UrlRemover
from .helpers import RecentOrderedDict

logger = logging.getLogger(__name__)


class Index(RecentOrderedDict):
    &#34;&#34;&#34;Files index dict.

    ..todo:: make it database synced
    &#34;&#34;&#34;
    def __init__(self, *args, **kwargs):
        super(Index, self).__init__(*args, **kwargs)
        self.lock = threading.Lock()

    def add_entry(self, k, v):
        with self.lock:
            self.__setitem__(k, v)

    def get_entry(self, k, default=None):
        return self.get(k, default=default)

    def add_resource(self, resource):
        location = resource.filepath
        self.add_entry(resource.context.url, location)
        if hasattr(resource.response, &#39;url&#39;):
            self.add_entry(resource.response.url, location)
            if resource.response.history:
                for r in resource.response.history:
                    self.add_entry(r.url, location)

    index_resource = add_resource


class SchedulerBase(object):
    &#34;&#34;&#34;A Synchronised resource processor.

    File paths would be based on the content-type header returned by the server
    but this would be slow because of being synchronous but is very reliable.
    &#34;&#34;&#34;
    style_tags = frozenset([&#39;link&#39;, &#39;style&#39;])
    img_tags = frozenset([&#39;img&#39;])
    script_tags = frozenset([&#39;script&#39;])
    meta_tags = frozenset([&#39;meta&#39;])
    internal_tags = (style_tags | img_tags | script_tags | meta_tags)
    external_tags = frozenset([&#39;a&#39;, &#39;form&#39;, &#39;iframe&#39;])
    tags = (internal_tags | external_tags)

    def __init__(self, default=None, **data):
        self.data = dict()
        self.data.update(data)
        self.default = default
        self.index = Index()
        self.block_external_domains = True
        self.logger = logger.getChild(self.__class__.__name__)

    def set_default(self, default):
        self.default = default
        self.logger.info(&#34;Set the scheduler default as: [%r]&#34; % default)

    def register_handler(self, key, value):
        self.data.__setitem__(key, value)
        self.logger.info(
            &#34;Set the scheduler handler for %s as: [%r]&#34; % (key, value))

    add_handler = register_handler

    def deregister_handler(self, key):
        self.data.__delitem__(key)
        self.logger.info(&#34;Removed the scheduler handler for: %s&#34; % key)

    remove_handler = deregister_handler

    def get_handler(self, key, *args, **params):
        if key not in self.data:
            if self.default is None:
                raise KeyError(key)
            return self.default(*args, **params)
        else:
            return self.data[key](*args, **params)

    invalid_schemas = tuple([
        &#39;data&#39;, &#39;javascript&#39;, &#39;mailto&#39;, &#39;tel&#39;,
    ])

    def validate_url(self, url):
        if not isinstance(url, string_types):
            self.logger.error(
                &#34;Expected string type, got %r&#34; % url)
            return False
        scheme, host, port, path, query, frag = urlparse(url)
        if scheme in self.invalid_schemas:
            self.logger.error(
                &#34;Invalid url schema: [%s] for url: [%s]&#34;
                % (scheme, url))
            return False
        #: TODO: Add a user validation of the url before blocking
        return True

    def validate_resource(self, resource):
        if not isinstance(resource, GenericResource):
            self.logger.error(
                &#34;Expected GenericResource, got %r&#34; % resource)
            return False
        if isinstance(resource, VoidResource):
            self.logger.error(
                &#34;Skipping VoidResource: %r&#34; % resource)
            return False
        if not isinstance(resource.url, string_types):
            self.logger.error(
                &#34;Expected url of string type, got %r&#34; % resource.url)
            return False
        if isinstance(resource, HTMLResource) and self.block_external_domains:
            # FIXME: Change the algorithm to evaluate redirects.
            # print(resource.url, resource.context)
            if not resource.url.startswith(resource.context.base_url):
                self.logger.error(
                    &#34;Blocked resource on external domain: %s&#34; % resource.url)
                return False
        return self.validate_url(resource.url)

    def handle_resource(self, resource):
        indexed = self.index.get_entry(resource.url)
        if indexed:
            self.logger.debug(
                &#34;[Cache] Resource Key: [%s] is available in the cache with value: [%s]&#34;
                % (resource.url, indexed)
            )
            # modify the resources path resolution mechanism.
            return resource.__dict__.__setitem__(&#39;filepath&#39;, indexed)

        #: Update the index before doing any processing so that later calls
        #: in index finds this entry without going in infinite recursion
        #: Response could have been already present on disk
        self.index.add_entry(resource.context.url, resource.filepath)

        if self.validate_resource(resource):
            self.logger.debug(&#34;Processing valid resource: %r&#34; % resource)
            return self._handle_resource(resource)
        self.logger.error(&#34;Discarding invalid resource: %r&#34; % resource)

    def _handle_resource(self, resource):
        raise NotImplementedError()


class Collector(SchedulerBase):
    &#34;&#34;&#34;A simple resource collector to use when debugging
    or requires manual collection of sub-files.&#34;&#34;&#34;
    def __init__(self, *args, **kwargs):
        super(Collector, self).__init__(*args, **kwargs)
        self.children = list()

    def _handle_resource(self, resource):
        self.children.append(resource)


class Scheduler(SchedulerBase):
    def _handle_resource(self, resource):
        try:
            self.logger.debug(&#39;Scheduler trying to get resource at: [%s]&#39; % resource.url)
            resource.get(resource.context.url)
            # NOTE :meth:`get` can change the :attr:`filepath` of the resource
            self.index.add_resource(resource)
        except ConnectionError:
            self.logger.error(
                &#34;Scheduler ConnectionError Failed to retrieve resource from [%s]&#34;
                % resource.url)
            # self.index.add_entry(resource.url, resource.filepath)
        except Exception as e:
            self.logger.exception(e)
            # self.index.add_entry(resource.url, resource.filepath)
        else:
            self.logger.debug(&#39;Scheduler running handler for: [%s]&#39; % resource.url)
            resource.retrieve()
        self.index.add_resource(resource)


class ThreadingScheduler(Scheduler):
    def __init__(self, *args, **kwargs):
        super(ThreadingScheduler, self).__init__(*args, **kwargs)
        self.threads = weakref.WeakSet()
        self.timeout = None

    def __del__(self):
        self.close()

    def close(self, timeout=None):
        if not timeout:
            timeout = self.timeout
        threads = self.threads
        self.threads = None
        for thread in threads:
            if thread.is_alive() and thread is not threading.current_thread():
                thread.join(timeout)

    def _handle_resource(self, resource):
        def run(r):
            try:
                self.logger.debug(&#39;Scheduler trying to get resource at: [%s]&#39; % r.url)
                # r.response = r.session.get(r.context.url)
                # XXX we do not want the url changing thus changing the target
                # file path along with it.
                r.get(r.context.url)
                self.logger.debug(&#39;Scheduler running handler for: [%s]&#39; % r.url)
                r.retrieve()
                return r.context.url, r.filepath
            except Exception as e:
                self.logger.debug(&#39;Exception encountered in retrieval: [%e]&#39; % e)

            finally:
                return r.context.url, r.filepath
        thread = threading.Thread(target=run, args=(resource,))
        thread.start()
        self.threads.add(thread)


class GEventScheduler(Scheduler):
    def __init__(self, maxsize=None, *args, **kwargs):
        super(GEventScheduler, self).__init__(*args, **kwargs)
        try:
            from gevent.pool import Pool
        except ImportError:
            raise ImportError(
                &#34;gevent module is not installed. &#34;
                &#34;Install it using pip: $ pip install gevent&#34;
            )
        self.pool = Pool(maxsize)

    def __del__(self):
        self.close()

    def close(self, timeout=None):
        self.pool.kill(timeout=timeout)

    def _handle_resource(self, resource):
        def run(r):
            self.logger.debug(&#39;Scheduler trying to get resource at: [%s]&#39; % resource.url)
            r.response = r.session.get(r.context.url)
            self.logger.debug(&#39;Scheduler running retrieving process: [%s]&#39; % resource.url)
            r.retrieve()
            return r.context.url, r.filepath

        g = self.pool.spawn(run, resource)
        g.link_value(lambda gl: logger.info(&#34;Written the file from &lt;%s&gt; to &lt;%s&gt;&#34; % gl.value))
        g.link_exception(lambda gl: logger.error(str(gl.exception)))


if PY3:
    class ThreadPoolScheduler(Scheduler):
        def __init__(self, maxsize=None, *args, **kwargs):
            super(ThreadPoolScheduler, self).__init__(*args, **kwargs)
            import concurrent.futures
            self.pool = concurrent.futures.ThreadPoolExecutor(maxsize)

        def __del__(self):
            self.close()

        def close(self, wait=None):
            self.pool.shutdown(wait)

        def _handle_resource(self, resource):
            def run(r):
                self.logger.debug(&#39;Scheduler trying to get resource at: [%s]&#39; % resource.url)
                r.response = r.session.get(r.context.url)
                self.logger.debug(&#39;Scheduler running retrieving process: [%s]&#39; % resource.url)
                r.retrieve()
                return r.context.url, r.filepath

            def callback(ret):
                if ret.exception():
                    self.logger.error(str(ret.exception()))
                else:
                    self.logger.info(&#34;Written the file from &lt;%s&gt; to &lt;%s&gt;&#34; % ret.result())

            g = self.pool.submit(run, resource)
            g.add_done_callback(callback)

    def thread_pool_default_scheduler(maxsize=4):
        ans = ThreadPoolScheduler(maxsize=maxsize)
        fac = default_scheduler()
        ans.default = fac.default
        ans.data = fac.data
        del fac
        return ans

    def thread_pool_crawler_scheduler(maxsize=4):
        ans = thread_pool_default_scheduler(maxsize=maxsize)
        for k in ans.meta_tags:
            ans.register_handler(k, HTMLResource)
        for k in ans.external_tags:
            ans.register_handler(k, HTMLResource)
        return ans

else:
    class ThreadPoolScheduler(object):
        def __init__(self, *args, **kwargs):
            raise RuntimeError(
                &#34;Python 2 does not have `futures` modules, &#34;
                &#34;hence you should use any other scheduler link gevent.!&#34;
            )

    def thread_pool_scheduler(maxsize=4):
        raise RuntimeError(
            &#34;Python 2 does not have futures modules, &#34;
            &#34;hence you should use any other scheduler link gevent.!&#34;, maxsize
        )

    def thread_pool_crawler_scheduler(maxsize=4):
        raise RuntimeError(
            &#34;Python 2 does not have futures modules, &#34;
            &#34;hence you should use any other scheduler link gevent.!&#34;, maxsize
        )


def default_scheduler():
    ans = Scheduler()
    ans.default = GenericResource
    for k in ans.style_tags:
        ans.register_handler(k, CSSResource)
    for k in ans.img_tags:
        ans.register_handler(k, GenericResource)
    for k in ans.script_tags:
        ans.register_handler(k, JSResource)
    for k in ans.meta_tags:
        ans.register_handler(k, GenericResource)
    for k in ans.external_tags:
        ans.register_handler(k, AbsoluteUrlResource)
    return ans


def no_js_scheduler():
    ans = default_scheduler()
    for k in ans.script_tags:
        ans.register_handler(k, UrlRemover)
    return ans


def crawler_scheduler():
    ans = default_scheduler()
    for k in ans.meta_tags:
        ans.register_handler(k, HTMLResource)
    for k in ans.external_tags:
        ans.register_handler(k, HTMLResource)
    return ans


def threading_default_scheduler(timeout=None):
    ans = ThreadingScheduler()
    ans.timeout = timeout
    fac = default_scheduler()
    ans.default = fac.default
    ans.data = fac.data
    del fac
    return ans


def threading_crawler_scheduler(timeout=None):
    ans = threading_default_scheduler()
    ans.timeout = timeout
    for k in ans.meta_tags:
        ans.register_handler(k, HTMLResource)
    for k in ans.external_tags:
        ans.register_handler(k, HTMLResource)
    return ans


def gevent_default_scheduler(maxsize=4):
    ans = GEventScheduler(maxsize=maxsize)
    fac = default_scheduler()
    ans.default = fac.default
    ans.data = fac.data
    del fac
    return ans


def gevent_crawler_scheduler():
    ans = gevent_default_scheduler()
    for k in ans.meta_tags:
        ans.register_handler(k, HTMLResource)
    for k in ans.external_tags:
        ans.register_handler(k, HTMLResource)
    return ans


def base64_scheduler():
    raise NotImplemented</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pywebcopy.schedulers.base64_scheduler"><code class="name flex">
<span>def <span class="ident">base64_scheduler</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base64_scheduler():
    raise NotImplemented</code></pre>
</details>
</dd>
<dt id="pywebcopy.schedulers.crawler_scheduler"><code class="name flex">
<span>def <span class="ident">crawler_scheduler</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crawler_scheduler():
    ans = default_scheduler()
    for k in ans.meta_tags:
        ans.register_handler(k, HTMLResource)
    for k in ans.external_tags:
        ans.register_handler(k, HTMLResource)
    return ans</code></pre>
</details>
</dd>
<dt id="pywebcopy.schedulers.default_scheduler"><code class="name flex">
<span>def <span class="ident">default_scheduler</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_scheduler():
    ans = Scheduler()
    ans.default = GenericResource
    for k in ans.style_tags:
        ans.register_handler(k, CSSResource)
    for k in ans.img_tags:
        ans.register_handler(k, GenericResource)
    for k in ans.script_tags:
        ans.register_handler(k, JSResource)
    for k in ans.meta_tags:
        ans.register_handler(k, GenericResource)
    for k in ans.external_tags:
        ans.register_handler(k, AbsoluteUrlResource)
    return ans</code></pre>
</details>
</dd>
<dt id="pywebcopy.schedulers.gevent_crawler_scheduler"><code class="name flex">
<span>def <span class="ident">gevent_crawler_scheduler</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gevent_crawler_scheduler():
    ans = gevent_default_scheduler()
    for k in ans.meta_tags:
        ans.register_handler(k, HTMLResource)
    for k in ans.external_tags:
        ans.register_handler(k, HTMLResource)
    return ans</code></pre>
</details>
</dd>
<dt id="pywebcopy.schedulers.gevent_default_scheduler"><code class="name flex">
<span>def <span class="ident">gevent_default_scheduler</span></span>(<span>maxsize=4)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gevent_default_scheduler(maxsize=4):
    ans = GEventScheduler(maxsize=maxsize)
    fac = default_scheduler()
    ans.default = fac.default
    ans.data = fac.data
    del fac
    return ans</code></pre>
</details>
</dd>
<dt id="pywebcopy.schedulers.no_js_scheduler"><code class="name flex">
<span>def <span class="ident">no_js_scheduler</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def no_js_scheduler():
    ans = default_scheduler()
    for k in ans.script_tags:
        ans.register_handler(k, UrlRemover)
    return ans</code></pre>
</details>
</dd>
<dt id="pywebcopy.schedulers.thread_pool_crawler_scheduler"><code class="name flex">
<span>def <span class="ident">thread_pool_crawler_scheduler</span></span>(<span>maxsize=4)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thread_pool_crawler_scheduler(maxsize=4):
    ans = thread_pool_default_scheduler(maxsize=maxsize)
    for k in ans.meta_tags:
        ans.register_handler(k, HTMLResource)
    for k in ans.external_tags:
        ans.register_handler(k, HTMLResource)
    return ans</code></pre>
</details>
</dd>
<dt id="pywebcopy.schedulers.thread_pool_default_scheduler"><code class="name flex">
<span>def <span class="ident">thread_pool_default_scheduler</span></span>(<span>maxsize=4)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thread_pool_default_scheduler(maxsize=4):
    ans = ThreadPoolScheduler(maxsize=maxsize)
    fac = default_scheduler()
    ans.default = fac.default
    ans.data = fac.data
    del fac
    return ans</code></pre>
</details>
</dd>
<dt id="pywebcopy.schedulers.threading_crawler_scheduler"><code class="name flex">
<span>def <span class="ident">threading_crawler_scheduler</span></span>(<span>timeout=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def threading_crawler_scheduler(timeout=None):
    ans = threading_default_scheduler()
    ans.timeout = timeout
    for k in ans.meta_tags:
        ans.register_handler(k, HTMLResource)
    for k in ans.external_tags:
        ans.register_handler(k, HTMLResource)
    return ans</code></pre>
</details>
</dd>
<dt id="pywebcopy.schedulers.threading_default_scheduler"><code class="name flex">
<span>def <span class="ident">threading_default_scheduler</span></span>(<span>timeout=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def threading_default_scheduler(timeout=None):
    ans = ThreadingScheduler()
    ans.timeout = timeout
    fac = default_scheduler()
    ans.default = fac.default
    ans.data = fac.data
    del fac
    return ans</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pywebcopy.schedulers.Collector"><code class="flex name class">
<span>class <span class="ident">Collector</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A simple resource collector to use when debugging
or requires manual collection of sub-files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Collector(SchedulerBase):
    &#34;&#34;&#34;A simple resource collector to use when debugging
    or requires manual collection of sub-files.&#34;&#34;&#34;
    def __init__(self, *args, **kwargs):
        super(Collector, self).__init__(*args, **kwargs)
        self.children = list()

    def _handle_resource(self, resource):
        self.children.append(resource)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywebcopy.schedulers.SchedulerBase" href="#pywebcopy.schedulers.SchedulerBase">SchedulerBase</a></li>
</ul>
</dd>
<dt id="pywebcopy.schedulers.GEventScheduler"><code class="flex name class">
<span>class <span class="ident">GEventScheduler</span></span>
<span>(</span><span>maxsize=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A Synchronised resource processor.</p>
<p>File paths would be based on the content-type header returned by the server
but this would be slow because of being synchronous but is very reliable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GEventScheduler(Scheduler):
    def __init__(self, maxsize=None, *args, **kwargs):
        super(GEventScheduler, self).__init__(*args, **kwargs)
        try:
            from gevent.pool import Pool
        except ImportError:
            raise ImportError(
                &#34;gevent module is not installed. &#34;
                &#34;Install it using pip: $ pip install gevent&#34;
            )
        self.pool = Pool(maxsize)

    def __del__(self):
        self.close()

    def close(self, timeout=None):
        self.pool.kill(timeout=timeout)

    def _handle_resource(self, resource):
        def run(r):
            self.logger.debug(&#39;Scheduler trying to get resource at: [%s]&#39; % resource.url)
            r.response = r.session.get(r.context.url)
            self.logger.debug(&#39;Scheduler running retrieving process: [%s]&#39; % resource.url)
            r.retrieve()
            return r.context.url, r.filepath

        g = self.pool.spawn(run, resource)
        g.link_value(lambda gl: logger.info(&#34;Written the file from &lt;%s&gt; to &lt;%s&gt;&#34; % gl.value))
        g.link_exception(lambda gl: logger.error(str(gl.exception)))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywebcopy.schedulers.Scheduler" href="#pywebcopy.schedulers.Scheduler">Scheduler</a></li>
<li><a title="pywebcopy.schedulers.SchedulerBase" href="#pywebcopy.schedulers.SchedulerBase">SchedulerBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywebcopy.schedulers.GEventScheduler.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self, timeout=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self, timeout=None):
    self.pool.kill(timeout=timeout)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pywebcopy.schedulers.Index"><code class="flex name class">
<span>class <span class="ident">Index</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Files index dict.</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>make it database synced</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Index(RecentOrderedDict):
    &#34;&#34;&#34;Files index dict.

    ..todo:: make it database synced
    &#34;&#34;&#34;
    def __init__(self, *args, **kwargs):
        super(Index, self).__init__(*args, **kwargs)
        self.lock = threading.Lock()

    def add_entry(self, k, v):
        with self.lock:
            self.__setitem__(k, v)

    def get_entry(self, k, default=None):
        return self.get(k, default=default)

    def add_resource(self, resource):
        location = resource.filepath
        self.add_entry(resource.context.url, location)
        if hasattr(resource.response, &#39;url&#39;):
            self.add_entry(resource.response.url, location)
            if resource.response.history:
                for r in resource.response.history:
                    self.add_entry(r.url, location)

    index_resource = add_resource</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywebcopy.helpers.RecentOrderedDict" href="helpers.html#pywebcopy.helpers.RecentOrderedDict">RecentOrderedDict</a></li>
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywebcopy.schedulers.Index.add_entry"><code class="name flex">
<span>def <span class="ident">add_entry</span></span>(<span>self, k, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_entry(self, k, v):
    with self.lock:
        self.__setitem__(k, v)</code></pre>
</details>
</dd>
<dt id="pywebcopy.schedulers.Index.add_resource"><code class="name flex">
<span>def <span class="ident">add_resource</span></span>(<span>self, resource)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_resource(self, resource):
    location = resource.filepath
    self.add_entry(resource.context.url, location)
    if hasattr(resource.response, &#39;url&#39;):
        self.add_entry(resource.response.url, location)
        if resource.response.history:
            for r in resource.response.history:
                self.add_entry(r.url, location)</code></pre>
</details>
</dd>
<dt id="pywebcopy.schedulers.Index.get_entry"><code class="name flex">
<span>def <span class="ident">get_entry</span></span>(<span>self, k, default=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_entry(self, k, default=None):
    return self.get(k, default=default)</code></pre>
</details>
</dd>
<dt id="pywebcopy.schedulers.Index.index_resource"><code class="name flex">
<span>def <span class="ident">index_resource</span></span>(<span>self, resource)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_resource(self, resource):
    location = resource.filepath
    self.add_entry(resource.context.url, location)
    if hasattr(resource.response, &#39;url&#39;):
        self.add_entry(resource.response.url, location)
        if resource.response.history:
            for r in resource.response.history:
                self.add_entry(r.url, location)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywebcopy.helpers.RecentOrderedDict" href="helpers.html#pywebcopy.helpers.RecentOrderedDict">RecentOrderedDict</a></b></code>:
<ul class="hlist">
<li><code><a title="pywebcopy.helpers.RecentOrderedDict.items" href="helpers.html#pywebcopy.helpers.RecentOrderedDict.items">items</a></code></li>
<li><code><a title="pywebcopy.helpers.RecentOrderedDict.keys" href="helpers.html#pywebcopy.helpers.RecentOrderedDict.keys">keys</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywebcopy.schedulers.Scheduler"><code class="flex name class">
<span>class <span class="ident">Scheduler</span></span>
<span>(</span><span>default=None, **data)</span>
</code></dt>
<dd>
<div class="desc"><p>A Synchronised resource processor.</p>
<p>File paths would be based on the content-type header returned by the server
but this would be slow because of being synchronous but is very reliable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Scheduler(SchedulerBase):
    def _handle_resource(self, resource):
        try:
            self.logger.debug(&#39;Scheduler trying to get resource at: [%s]&#39; % resource.url)
            resource.get(resource.context.url)
            # NOTE :meth:`get` can change the :attr:`filepath` of the resource
            self.index.add_resource(resource)
        except ConnectionError:
            self.logger.error(
                &#34;Scheduler ConnectionError Failed to retrieve resource from [%s]&#34;
                % resource.url)
            # self.index.add_entry(resource.url, resource.filepath)
        except Exception as e:
            self.logger.exception(e)
            # self.index.add_entry(resource.url, resource.filepath)
        else:
            self.logger.debug(&#39;Scheduler running handler for: [%s]&#39; % resource.url)
            resource.retrieve()
        self.index.add_resource(resource)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywebcopy.schedulers.SchedulerBase" href="#pywebcopy.schedulers.SchedulerBase">SchedulerBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pywebcopy.schedulers.GEventScheduler" href="#pywebcopy.schedulers.GEventScheduler">GEventScheduler</a></li>
<li><a title="pywebcopy.schedulers.ThreadPoolScheduler" href="#pywebcopy.schedulers.ThreadPoolScheduler">ThreadPoolScheduler</a></li>
<li><a title="pywebcopy.schedulers.ThreadingScheduler" href="#pywebcopy.schedulers.ThreadingScheduler">ThreadingScheduler</a></li>
</ul>
</dd>
<dt id="pywebcopy.schedulers.SchedulerBase"><code class="flex name class">
<span>class <span class="ident">SchedulerBase</span></span>
<span>(</span><span>default=None, **data)</span>
</code></dt>
<dd>
<div class="desc"><p>A Synchronised resource processor.</p>
<p>File paths would be based on the content-type header returned by the server
but this would be slow because of being synchronous but is very reliable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SchedulerBase(object):
    &#34;&#34;&#34;A Synchronised resource processor.

    File paths would be based on the content-type header returned by the server
    but this would be slow because of being synchronous but is very reliable.
    &#34;&#34;&#34;
    style_tags = frozenset([&#39;link&#39;, &#39;style&#39;])
    img_tags = frozenset([&#39;img&#39;])
    script_tags = frozenset([&#39;script&#39;])
    meta_tags = frozenset([&#39;meta&#39;])
    internal_tags = (style_tags | img_tags | script_tags | meta_tags)
    external_tags = frozenset([&#39;a&#39;, &#39;form&#39;, &#39;iframe&#39;])
    tags = (internal_tags | external_tags)

    def __init__(self, default=None, **data):
        self.data = dict()
        self.data.update(data)
        self.default = default
        self.index = Index()
        self.block_external_domains = True
        self.logger = logger.getChild(self.__class__.__name__)

    def set_default(self, default):
        self.default = default
        self.logger.info(&#34;Set the scheduler default as: [%r]&#34; % default)

    def register_handler(self, key, value):
        self.data.__setitem__(key, value)
        self.logger.info(
            &#34;Set the scheduler handler for %s as: [%r]&#34; % (key, value))

    add_handler = register_handler

    def deregister_handler(self, key):
        self.data.__delitem__(key)
        self.logger.info(&#34;Removed the scheduler handler for: %s&#34; % key)

    remove_handler = deregister_handler

    def get_handler(self, key, *args, **params):
        if key not in self.data:
            if self.default is None:
                raise KeyError(key)
            return self.default(*args, **params)
        else:
            return self.data[key](*args, **params)

    invalid_schemas = tuple([
        &#39;data&#39;, &#39;javascript&#39;, &#39;mailto&#39;, &#39;tel&#39;,
    ])

    def validate_url(self, url):
        if not isinstance(url, string_types):
            self.logger.error(
                &#34;Expected string type, got %r&#34; % url)
            return False
        scheme, host, port, path, query, frag = urlparse(url)
        if scheme in self.invalid_schemas:
            self.logger.error(
                &#34;Invalid url schema: [%s] for url: [%s]&#34;
                % (scheme, url))
            return False
        #: TODO: Add a user validation of the url before blocking
        return True

    def validate_resource(self, resource):
        if not isinstance(resource, GenericResource):
            self.logger.error(
                &#34;Expected GenericResource, got %r&#34; % resource)
            return False
        if isinstance(resource, VoidResource):
            self.logger.error(
                &#34;Skipping VoidResource: %r&#34; % resource)
            return False
        if not isinstance(resource.url, string_types):
            self.logger.error(
                &#34;Expected url of string type, got %r&#34; % resource.url)
            return False
        if isinstance(resource, HTMLResource) and self.block_external_domains:
            # FIXME: Change the algorithm to evaluate redirects.
            # print(resource.url, resource.context)
            if not resource.url.startswith(resource.context.base_url):
                self.logger.error(
                    &#34;Blocked resource on external domain: %s&#34; % resource.url)
                return False
        return self.validate_url(resource.url)

    def handle_resource(self, resource):
        indexed = self.index.get_entry(resource.url)
        if indexed:
            self.logger.debug(
                &#34;[Cache] Resource Key: [%s] is available in the cache with value: [%s]&#34;
                % (resource.url, indexed)
            )
            # modify the resources path resolution mechanism.
            return resource.__dict__.__setitem__(&#39;filepath&#39;, indexed)

        #: Update the index before doing any processing so that later calls
        #: in index finds this entry without going in infinite recursion
        #: Response could have been already present on disk
        self.index.add_entry(resource.context.url, resource.filepath)

        if self.validate_resource(resource):
            self.logger.debug(&#34;Processing valid resource: %r&#34; % resource)
            return self._handle_resource(resource)
        self.logger.error(&#34;Discarding invalid resource: %r&#34; % resource)

    def _handle_resource(self, resource):
        raise NotImplementedError()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pywebcopy.schedulers.Collector" href="#pywebcopy.schedulers.Collector">Collector</a></li>
<li><a title="pywebcopy.schedulers.Scheduler" href="#pywebcopy.schedulers.Scheduler">Scheduler</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pywebcopy.schedulers.SchedulerBase.external_tags"><code class="name">var <span class="ident">external_tags</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pywebcopy.schedulers.SchedulerBase.img_tags"><code class="name">var <span class="ident">img_tags</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pywebcopy.schedulers.SchedulerBase.internal_tags"><code class="name">var <span class="ident">internal_tags</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pywebcopy.schedulers.SchedulerBase.invalid_schemas"><code class="name">var <span class="ident">invalid_schemas</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pywebcopy.schedulers.SchedulerBase.meta_tags"><code class="name">var <span class="ident">meta_tags</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pywebcopy.schedulers.SchedulerBase.script_tags"><code class="name">var <span class="ident">script_tags</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pywebcopy.schedulers.SchedulerBase.style_tags"><code class="name">var <span class="ident">style_tags</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pywebcopy.schedulers.SchedulerBase.tags"><code class="name">var <span class="ident">tags</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pywebcopy.schedulers.SchedulerBase.add_handler"><code class="name flex">
<span>def <span class="ident">add_handler</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_handler(self, key, value):
    self.data.__setitem__(key, value)
    self.logger.info(
        &#34;Set the scheduler handler for %s as: [%r]&#34; % (key, value))</code></pre>
</details>
</dd>
<dt id="pywebcopy.schedulers.SchedulerBase.deregister_handler"><code class="name flex">
<span>def <span class="ident">deregister_handler</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deregister_handler(self, key):
    self.data.__delitem__(key)
    self.logger.info(&#34;Removed the scheduler handler for: %s&#34; % key)</code></pre>
</details>
</dd>
<dt id="pywebcopy.schedulers.SchedulerBase.get_handler"><code class="name flex">
<span>def <span class="ident">get_handler</span></span>(<span>self, key, *args, **params)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_handler(self, key, *args, **params):
    if key not in self.data:
        if self.default is None:
            raise KeyError(key)
        return self.default(*args, **params)
    else:
        return self.data[key](*args, **params)</code></pre>
</details>
</dd>
<dt id="pywebcopy.schedulers.SchedulerBase.handle_resource"><code class="name flex">
<span>def <span class="ident">handle_resource</span></span>(<span>self, resource)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_resource(self, resource):
    indexed = self.index.get_entry(resource.url)
    if indexed:
        self.logger.debug(
            &#34;[Cache] Resource Key: [%s] is available in the cache with value: [%s]&#34;
            % (resource.url, indexed)
        )
        # modify the resources path resolution mechanism.
        return resource.__dict__.__setitem__(&#39;filepath&#39;, indexed)

    #: Update the index before doing any processing so that later calls
    #: in index finds this entry without going in infinite recursion
    #: Response could have been already present on disk
    self.index.add_entry(resource.context.url, resource.filepath)

    if self.validate_resource(resource):
        self.logger.debug(&#34;Processing valid resource: %r&#34; % resource)
        return self._handle_resource(resource)
    self.logger.error(&#34;Discarding invalid resource: %r&#34; % resource)</code></pre>
</details>
</dd>
<dt id="pywebcopy.schedulers.SchedulerBase.register_handler"><code class="name flex">
<span>def <span class="ident">register_handler</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_handler(self, key, value):
    self.data.__setitem__(key, value)
    self.logger.info(
        &#34;Set the scheduler handler for %s as: [%r]&#34; % (key, value))</code></pre>
</details>
</dd>
<dt id="pywebcopy.schedulers.SchedulerBase.remove_handler"><code class="name flex">
<span>def <span class="ident">remove_handler</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deregister_handler(self, key):
    self.data.__delitem__(key)
    self.logger.info(&#34;Removed the scheduler handler for: %s&#34; % key)</code></pre>
</details>
</dd>
<dt id="pywebcopy.schedulers.SchedulerBase.set_default"><code class="name flex">
<span>def <span class="ident">set_default</span></span>(<span>self, default)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_default(self, default):
    self.default = default
    self.logger.info(&#34;Set the scheduler default as: [%r]&#34; % default)</code></pre>
</details>
</dd>
<dt id="pywebcopy.schedulers.SchedulerBase.validate_resource"><code class="name flex">
<span>def <span class="ident">validate_resource</span></span>(<span>self, resource)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_resource(self, resource):
    if not isinstance(resource, GenericResource):
        self.logger.error(
            &#34;Expected GenericResource, got %r&#34; % resource)
        return False
    if isinstance(resource, VoidResource):
        self.logger.error(
            &#34;Skipping VoidResource: %r&#34; % resource)
        return False
    if not isinstance(resource.url, string_types):
        self.logger.error(
            &#34;Expected url of string type, got %r&#34; % resource.url)
        return False
    if isinstance(resource, HTMLResource) and self.block_external_domains:
        # FIXME: Change the algorithm to evaluate redirects.
        # print(resource.url, resource.context)
        if not resource.url.startswith(resource.context.base_url):
            self.logger.error(
                &#34;Blocked resource on external domain: %s&#34; % resource.url)
            return False
    return self.validate_url(resource.url)</code></pre>
</details>
</dd>
<dt id="pywebcopy.schedulers.SchedulerBase.validate_url"><code class="name flex">
<span>def <span class="ident">validate_url</span></span>(<span>self, url)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_url(self, url):
    if not isinstance(url, string_types):
        self.logger.error(
            &#34;Expected string type, got %r&#34; % url)
        return False
    scheme, host, port, path, query, frag = urlparse(url)
    if scheme in self.invalid_schemas:
        self.logger.error(
            &#34;Invalid url schema: [%s] for url: [%s]&#34;
            % (scheme, url))
        return False
    #: TODO: Add a user validation of the url before blocking
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pywebcopy.schedulers.ThreadPoolScheduler"><code class="flex name class">
<span>class <span class="ident">ThreadPoolScheduler</span></span>
<span>(</span><span>maxsize=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A Synchronised resource processor.</p>
<p>File paths would be based on the content-type header returned by the server
but this would be slow because of being synchronous but is very reliable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ThreadPoolScheduler(Scheduler):
    def __init__(self, maxsize=None, *args, **kwargs):
        super(ThreadPoolScheduler, self).__init__(*args, **kwargs)
        import concurrent.futures
        self.pool = concurrent.futures.ThreadPoolExecutor(maxsize)

    def __del__(self):
        self.close()

    def close(self, wait=None):
        self.pool.shutdown(wait)

    def _handle_resource(self, resource):
        def run(r):
            self.logger.debug(&#39;Scheduler trying to get resource at: [%s]&#39; % resource.url)
            r.response = r.session.get(r.context.url)
            self.logger.debug(&#39;Scheduler running retrieving process: [%s]&#39; % resource.url)
            r.retrieve()
            return r.context.url, r.filepath

        def callback(ret):
            if ret.exception():
                self.logger.error(str(ret.exception()))
            else:
                self.logger.info(&#34;Written the file from &lt;%s&gt; to &lt;%s&gt;&#34; % ret.result())

        g = self.pool.submit(run, resource)
        g.add_done_callback(callback)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywebcopy.schedulers.Scheduler" href="#pywebcopy.schedulers.Scheduler">Scheduler</a></li>
<li><a title="pywebcopy.schedulers.SchedulerBase" href="#pywebcopy.schedulers.SchedulerBase">SchedulerBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywebcopy.schedulers.ThreadPoolScheduler.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self, wait=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self, wait=None):
    self.pool.shutdown(wait)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pywebcopy.schedulers.ThreadingScheduler"><code class="flex name class">
<span>class <span class="ident">ThreadingScheduler</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A Synchronised resource processor.</p>
<p>File paths would be based on the content-type header returned by the server
but this would be slow because of being synchronous but is very reliable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ThreadingScheduler(Scheduler):
    def __init__(self, *args, **kwargs):
        super(ThreadingScheduler, self).__init__(*args, **kwargs)
        self.threads = weakref.WeakSet()
        self.timeout = None

    def __del__(self):
        self.close()

    def close(self, timeout=None):
        if not timeout:
            timeout = self.timeout
        threads = self.threads
        self.threads = None
        for thread in threads:
            if thread.is_alive() and thread is not threading.current_thread():
                thread.join(timeout)

    def _handle_resource(self, resource):
        def run(r):
            try:
                self.logger.debug(&#39;Scheduler trying to get resource at: [%s]&#39; % r.url)
                # r.response = r.session.get(r.context.url)
                # XXX we do not want the url changing thus changing the target
                # file path along with it.
                r.get(r.context.url)
                self.logger.debug(&#39;Scheduler running handler for: [%s]&#39; % r.url)
                r.retrieve()
                return r.context.url, r.filepath
            except Exception as e:
                self.logger.debug(&#39;Exception encountered in retrieval: [%e]&#39; % e)

            finally:
                return r.context.url, r.filepath
        thread = threading.Thread(target=run, args=(resource,))
        thread.start()
        self.threads.add(thread)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywebcopy.schedulers.Scheduler" href="#pywebcopy.schedulers.Scheduler">Scheduler</a></li>
<li><a title="pywebcopy.schedulers.SchedulerBase" href="#pywebcopy.schedulers.SchedulerBase">SchedulerBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywebcopy.schedulers.ThreadingScheduler.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self, timeout=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self, timeout=None):
    if not timeout:
        timeout = self.timeout
    threads = self.threads
    self.threads = None
    for thread in threads:
        if thread.is_alive() and thread is not threading.current_thread():
            thread.join(timeout)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pywebcopy" href="index.html">pywebcopy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pywebcopy.schedulers.base64_scheduler" href="#pywebcopy.schedulers.base64_scheduler">base64_scheduler</a></code></li>
<li><code><a title="pywebcopy.schedulers.crawler_scheduler" href="#pywebcopy.schedulers.crawler_scheduler">crawler_scheduler</a></code></li>
<li><code><a title="pywebcopy.schedulers.default_scheduler" href="#pywebcopy.schedulers.default_scheduler">default_scheduler</a></code></li>
<li><code><a title="pywebcopy.schedulers.gevent_crawler_scheduler" href="#pywebcopy.schedulers.gevent_crawler_scheduler">gevent_crawler_scheduler</a></code></li>
<li><code><a title="pywebcopy.schedulers.gevent_default_scheduler" href="#pywebcopy.schedulers.gevent_default_scheduler">gevent_default_scheduler</a></code></li>
<li><code><a title="pywebcopy.schedulers.no_js_scheduler" href="#pywebcopy.schedulers.no_js_scheduler">no_js_scheduler</a></code></li>
<li><code><a title="pywebcopy.schedulers.thread_pool_crawler_scheduler" href="#pywebcopy.schedulers.thread_pool_crawler_scheduler">thread_pool_crawler_scheduler</a></code></li>
<li><code><a title="pywebcopy.schedulers.thread_pool_default_scheduler" href="#pywebcopy.schedulers.thread_pool_default_scheduler">thread_pool_default_scheduler</a></code></li>
<li><code><a title="pywebcopy.schedulers.threading_crawler_scheduler" href="#pywebcopy.schedulers.threading_crawler_scheduler">threading_crawler_scheduler</a></code></li>
<li><code><a title="pywebcopy.schedulers.threading_default_scheduler" href="#pywebcopy.schedulers.threading_default_scheduler">threading_default_scheduler</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pywebcopy.schedulers.Collector" href="#pywebcopy.schedulers.Collector">Collector</a></code></h4>
</li>
<li>
<h4><code><a title="pywebcopy.schedulers.GEventScheduler" href="#pywebcopy.schedulers.GEventScheduler">GEventScheduler</a></code></h4>
<ul class="">
<li><code><a title="pywebcopy.schedulers.GEventScheduler.close" href="#pywebcopy.schedulers.GEventScheduler.close">close</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywebcopy.schedulers.Index" href="#pywebcopy.schedulers.Index">Index</a></code></h4>
<ul class="">
<li><code><a title="pywebcopy.schedulers.Index.add_entry" href="#pywebcopy.schedulers.Index.add_entry">add_entry</a></code></li>
<li><code><a title="pywebcopy.schedulers.Index.add_resource" href="#pywebcopy.schedulers.Index.add_resource">add_resource</a></code></li>
<li><code><a title="pywebcopy.schedulers.Index.get_entry" href="#pywebcopy.schedulers.Index.get_entry">get_entry</a></code></li>
<li><code><a title="pywebcopy.schedulers.Index.index_resource" href="#pywebcopy.schedulers.Index.index_resource">index_resource</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywebcopy.schedulers.Scheduler" href="#pywebcopy.schedulers.Scheduler">Scheduler</a></code></h4>
</li>
<li>
<h4><code><a title="pywebcopy.schedulers.SchedulerBase" href="#pywebcopy.schedulers.SchedulerBase">SchedulerBase</a></code></h4>
<ul class="two-column">
<li><code><a title="pywebcopy.schedulers.SchedulerBase.add_handler" href="#pywebcopy.schedulers.SchedulerBase.add_handler">add_handler</a></code></li>
<li><code><a title="pywebcopy.schedulers.SchedulerBase.deregister_handler" href="#pywebcopy.schedulers.SchedulerBase.deregister_handler">deregister_handler</a></code></li>
<li><code><a title="pywebcopy.schedulers.SchedulerBase.external_tags" href="#pywebcopy.schedulers.SchedulerBase.external_tags">external_tags</a></code></li>
<li><code><a title="pywebcopy.schedulers.SchedulerBase.get_handler" href="#pywebcopy.schedulers.SchedulerBase.get_handler">get_handler</a></code></li>
<li><code><a title="pywebcopy.schedulers.SchedulerBase.handle_resource" href="#pywebcopy.schedulers.SchedulerBase.handle_resource">handle_resource</a></code></li>
<li><code><a title="pywebcopy.schedulers.SchedulerBase.img_tags" href="#pywebcopy.schedulers.SchedulerBase.img_tags">img_tags</a></code></li>
<li><code><a title="pywebcopy.schedulers.SchedulerBase.internal_tags" href="#pywebcopy.schedulers.SchedulerBase.internal_tags">internal_tags</a></code></li>
<li><code><a title="pywebcopy.schedulers.SchedulerBase.invalid_schemas" href="#pywebcopy.schedulers.SchedulerBase.invalid_schemas">invalid_schemas</a></code></li>
<li><code><a title="pywebcopy.schedulers.SchedulerBase.meta_tags" href="#pywebcopy.schedulers.SchedulerBase.meta_tags">meta_tags</a></code></li>
<li><code><a title="pywebcopy.schedulers.SchedulerBase.register_handler" href="#pywebcopy.schedulers.SchedulerBase.register_handler">register_handler</a></code></li>
<li><code><a title="pywebcopy.schedulers.SchedulerBase.remove_handler" href="#pywebcopy.schedulers.SchedulerBase.remove_handler">remove_handler</a></code></li>
<li><code><a title="pywebcopy.schedulers.SchedulerBase.script_tags" href="#pywebcopy.schedulers.SchedulerBase.script_tags">script_tags</a></code></li>
<li><code><a title="pywebcopy.schedulers.SchedulerBase.set_default" href="#pywebcopy.schedulers.SchedulerBase.set_default">set_default</a></code></li>
<li><code><a title="pywebcopy.schedulers.SchedulerBase.style_tags" href="#pywebcopy.schedulers.SchedulerBase.style_tags">style_tags</a></code></li>
<li><code><a title="pywebcopy.schedulers.SchedulerBase.tags" href="#pywebcopy.schedulers.SchedulerBase.tags">tags</a></code></li>
<li><code><a title="pywebcopy.schedulers.SchedulerBase.validate_resource" href="#pywebcopy.schedulers.SchedulerBase.validate_resource">validate_resource</a></code></li>
<li><code><a title="pywebcopy.schedulers.SchedulerBase.validate_url" href="#pywebcopy.schedulers.SchedulerBase.validate_url">validate_url</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywebcopy.schedulers.ThreadPoolScheduler" href="#pywebcopy.schedulers.ThreadPoolScheduler">ThreadPoolScheduler</a></code></h4>
<ul class="">
<li><code><a title="pywebcopy.schedulers.ThreadPoolScheduler.close" href="#pywebcopy.schedulers.ThreadPoolScheduler.close">close</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywebcopy.schedulers.ThreadingScheduler" href="#pywebcopy.schedulers.ThreadingScheduler">ThreadingScheduler</a></code></h4>
<ul class="">
<li><code><a title="pywebcopy.schedulers.ThreadingScheduler.close" href="#pywebcopy.schedulers.ThreadingScheduler.close">close</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>