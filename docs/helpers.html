<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pywebcopy.helpers API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pywebcopy.helpers</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2020; Raja Tomar
# See license for more details
import time
import functools
import threading

from requests.compat import OrderedDict
from six import BytesIO
from six.moves.collections_abc import MutableMapping


class RecentOrderedDict(MutableMapping):
    &#34;&#34;&#34;
    A custom variant of the OrderedDict that ensures that the object most
    recently inserted or retrieved from the dictionary is at the top of the
    dictionary enumeration.
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        self._data = OrderedDict(*args, **kwargs)

    def __setitem__(self, key, value):
        if key in self._data:
            del self._data[key]
        self._data[key] = value

    def __getitem__(self, key):
        value = self._data[key]
        del self._data[key]
        self._data[key] = value
        return value

    def __delitem__(self, key):
        del self._data[key]

    def __iter__(self):
        return iter(self._data)

    def __len__(self):
        return len(self._data)

    def __contains__(self, value):
        return self._data.__contains__(value)

    def items(self):
        return self._data.items()

    def keys(self):
        return self._data.keys()


class ConcurrentDelay(object):
    &#34;&#34;&#34;
    Blocking waiter which calculates the delay irrespective of the
    waiting call rather than just waiting on the specified time.

    for example if time between two calls for delay are 10 seconds apart
    but the timeout is set for 1 second then the second call will not block
    but a successive third call will be blocked for 1 second before completing.
    &#34;&#34;&#34;

    def __init__(self, timeout=1 / 10):
        self._timeout = None
        self.set_timeout(timeout)
        self.start_time = time.time()
        self._cond = threading.Condition()
        # self.logger = logger.getChild(self.__class__.__name__)

    def set_timeout(self, t):
        if not isinstance(t, (int, float)):
            raise ValueError(&#34;Expected int or float, got %r&#34; % t)
        if t &lt;= -1:
            raise ValueError(&#34;Delay cannot be smaller than 0&#34;)
        self._timeout = t

    def delay(self):
        &#34;&#34;&#34;Delays until the timeout is completed&#34;&#34;&#34;
        with self._cond:
            current_time = time.time()
            diff_time = current_time - self.start_time
            # prevent none type values from waiting infinitely
            if isinstance(self._timeout, (int, float)) \
                    and not diff_time &gt;= self._timeout:
                # self.logger.debug(
                # &#34;Waiting on request for [%r] seconds!&#34; % self._timeout)
                self._cond.wait(self._timeout - diff_time)
            self.start_time = current_time


def lru_cache(maxsize=255, timeout=None):
    &#34;&#34;&#34;lru_cache(maxsize = 255, timeout = None) --&gt; returns a decorator which
    returns an instance (a descriptor).

        Purpose         - This decorator factory will wrap a function / instance method
                            and will supply a caching mechanism to the function.
                            For every given input params it will store the result in a queue
                            of maxsize size, and will return a cached ret_val
                            if the same parameters are passed.

        Params          - maxsize - int, the cache size limit, anything added above that will delete
                            the first values entered (FIFO).
                            This size is per instance, thus 1000 instances with maxsize of 255,
                            will contain at max 255K elements.
                        - timeout - int / float / None, every n seconds the cache is deleted,
                            regardless of usage. If None - cache will never be refreshed.

        Notes           - If an instance method is wrapped, each instance will have it&#39;s own cache
                            and it&#39;s own timeout.
                        - The wrapped function will have a cache_clear variable inserted
                            into it and may be called to clear it&#39;s specific cache.
                        - The wrapped function will maintain the original function&#39;s
                            docstring and name (wraps)
                        - The type of the wrapped function will no longer be that of a function
                            but either an instance of _LRU_Cache_class or a functools.partial type.

        On Error        - No error handling is done, in case an exception is raised - it will permeate up.
    &#34;&#34;&#34;

    class _LRU_Cache_class(object):
        # noinspection PyShadowingNames
        def __init__(self, input_func, max_size, timeout):
            self._input_func = input_func
            self._max_size = max_size
            self._timeout = timeout

            # This will store the cache for this function, format -
            # {caller1 : [OrderedDict1, last_refresh_time1], caller2 : [OrderedDict2, last_refresh_time2]}.
            #   In case of an instance method - the caller is the instance, in case called
            #   from a regular function - the caller is None.
            self._caches_dict = {}

        def cache_clear(self, caller=None):
            # Remove the cache for the caller, only if exists:
            if caller in self._caches_dict:
                del self._caches_dict[caller]
                self._caches_dict[caller] = [OrderedDict(), time.time()]

        def __get__(self, obj, obj_type):
            &#34;&#34;&#34; Called for instance methods &#34;&#34;&#34;
            return_func = functools.partial(self._cache_wrapper, obj)
            return_func.cache_clear = functools.partial(self.cache_clear, obj)
            # Return the wrapped function and wraps it to maintain the docstring and
            # the name of the original function:
            return functools.wraps(self._input_func)(return_func)

        def __call__(self, *args, **kwargs):
            &#34;&#34;&#34; Called for regular functions &#34;&#34;&#34;
            return self._cache_wrapper(None, *args, **kwargs)

        # Set the cache_clear function in the __call__ operator:
        __call__.cache_clear = cache_clear

        def _cache_wrapper(self, caller, *args, **kwargs):
            # Create a unique key including the types (in order to differentiate between 1 and &#39;1&#39;):
            kwargs_key = &#34;&#34;.join(map(lambda x: str(x) + str(type(kwargs[x])) + str(kwargs[x]), sorted(kwargs)))
            key = &#34;&#34;.join(map(lambda x: str(type(x)) + str(x), args)) + kwargs_key

            # Check if caller exists, if not create one:
            if caller not in self._caches_dict:
                self._caches_dict[caller] = [OrderedDict(), time.time()]
            else:
                # Validate in case the refresh time has passed:
                if self._timeout is not None:
                    if time.time() - self._caches_dict[caller][1] &gt; self._timeout:
                        self.cache_clear(caller)

            # Check if the key exists, if so - return it:
            cur_caller_cache_dict = self._caches_dict[caller][0]
            if key in cur_caller_cache_dict:
                return cur_caller_cache_dict[key]

            # Validate we didn&#39;t exceed the max_size:
            if len(cur_caller_cache_dict) &gt;= self._max_size:
                # Delete the first item in the dict:
                cur_caller_cache_dict.popitem(False)

            # Call the function and store the data in the cache (call it with
            # the caller in case it&#39;s an instance function - Ternary condition):
            cur_caller_cache_dict[key] = self._input_func(
                caller, *args, **kwargs) if caller is not None else self._input_func(
                *args, **kwargs
            )
            return cur_caller_cache_dict[key]

    # Return the decorator wrapping the class (also wraps the instance to
    # maintain the docstring and the name of the original function):
    return lambda input_func: functools.wraps(input_func)(_LRU_Cache_class(input_func, maxsize, timeout))


_missing = object()


class cached_property(property):
    &#34;&#34;&#34;A decorator that converts a function into a lazy property.  The
    function wrapped is called the first time to retrieve the result
    and then that calculated result is used the next time you access
    the value::

        class Foo(object):

            @cached_property
            def foo(self):
                # calculate something important here
                return 42

    The class has to have a `__dict__` in order for this property to
    work.
    &#34;&#34;&#34;

    # implementation detail: A subclass of python&#39;s builtin property
    # decorator, we override __get__ to check for a cached value. If one
    # chooses to invoke __get__ by hand the property will still work as
    # expected because the lookup logic is replicated in __get__ for
    # manual invocation.

    # noinspection PyMissingConstructor
    def __init__(self, func, name=None, doc=None):
        self.__name__ = name or func.__name__
        self.__module__ = func.__module__
        self.__doc__ = doc or func.__doc__
        self.func = func

    def __set__(self, obj, value):
        obj.__dict__[self.__name__] = value

    def __get__(self, obj, *args, **kwargs):
        if obj is None:
            return self
        value = obj.__dict__.get(self.__name__, _missing)
        if value is _missing:
            value = self.func(obj)
            obj.__dict__[self.__name__] = value
        return value


class CallbackFileWrapper(object):
    &#34;&#34;&#34;
    Small wrapper around a fp object which will tee everything read into a
    buffer, and when that file is closed it will execute a callback with the
    contents of that buffer.

    All attributes are proxied to the underlying file object.

    This class uses members with a double underscore (__) leading prefix so as
    not to accidentally shadow an attribute.
    &#34;&#34;&#34;

    def __init__(self, fp, callback=None):
        self.__buf = BytesIO()
        self.__fp = fp
        self.__callback = callback
        self.__once_done = False

    def __getattr__(self, name):
        # The vagaries of garbage collection means that self.__fp is
        # not always set.  By using __getattribute__ and the private
        # name[0] allows looking up the attribute value and raising an
        # AttributeError when it doesn&#39;t exist. This stop things from
        # infinitely recurring calls to getattr in the case where
        # self.__fp hasn&#39;t been set.
        #
        # [0] https://docs.python.org/2/reference/expressions.html#atom-identifiers
        fp = self.__getattribute__(&#34;_CallbackFileWrapper__fp&#34;)
        return getattr(fp, name)

    def __is_fp_closed(self):
        try:
            return self.__fp.fp is None

        except AttributeError:
            pass

        try:
            return self.__fp.closed

        except AttributeError:
            pass

        return False

    def close(self):
        if self.__callback:
            # self.__callback(self.__buf.getvalue())
            self.__callback()

        # We assign this to None here, because otherwise we can get into
        # really tricky problems where the CPython interpreter dead locks
        # because the callback is holding a reference to something which
        # has a __del__ method. Setting this to None breaks the cycle
        # and allows the garbage collector to do it&#39;s thing normally.
        self.__callback = None
        self.__once_done = True
        return self.__getattribute__(&#34;_CallbackFileWrapper__fp&#34;).close()

    def rewind(self):
        if self.__once_done:
            self.__fp.close()
            self.__fp = self.__buf
            self.__buf = BytesIO()
            self.__fp.seek(0)
            self.__once_done = False

    def read(self, amt=None):
        data = self.__fp.read(amt)
        self.__buf.write(data)
        if self.__is_fp_closed():
            self.close()
        return data

    def _safe_read(self, amt):
        data = self.__fp._safe_read(amt)
        if amt == 2 and data == b&#34;\r\n&#34;:
            # urllib executes this read to toss the CRLF at the end
            # of the chunk.
            return data

        self.__buf.write(data)
        if self.__is_fp_closed():
            self.close()
        return data


class RewindableResponse(object):
    &#34;&#34;&#34;
    Used by :class:`WebPage` to store current resource
    content to minimize the number of requests made while
    working with a page.
    &#34;&#34;&#34;
    def __init__(self, fp):
        self.fp = fp
        self.buffer = BytesIO()
        self.once_done = threading.Event()

    def __getattr__(self, name):
        fp = self.__getattribute__(&#34;fp&#34;)
        return getattr(fp, name)

    @classmethod
    def from_response(cls, response):
        response.raw.decode_content = True
        ans = cls(response.raw)
        return ans

    def read(self, n=None):
        if self.fp.closed:
            self.once_done.set()
        data = self.fp.read(n)
        self.buffer.write(data)
        if self.fp.closed:
            self.once_done.set()
        return data

    def rewind(self):
        if not self.once_done.is_set():
            return False
        self.fp.close()
        self.buffer.seek(0)
        self.fp = self.buffer
        self.buffer = BytesIO()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pywebcopy.helpers.lru_cache"><code class="name flex">
<span>def <span class="ident">lru_cache</span></span>(<span>maxsize=255, timeout=None)</span>
</code></dt>
<dd>
<div class="desc"><p>lru_cache(maxsize = 255, timeout = None) &ndash;&gt; returns a decorator which
returns an instance (a descriptor).</p>
<pre><code>Purpose         - This decorator factory will wrap a function / instance method
                    and will supply a caching mechanism to the function.
                    For every given input params it will store the result in a queue
                    of maxsize size, and will return a cached ret_val
                    if the same parameters are passed.

Params          - maxsize - int, the cache size limit, anything added above that will delete
                    the first values entered (FIFO).
                    This size is per instance, thus 1000 instances with maxsize of 255,
                    will contain at max 255K elements.
                - timeout - int / float / None, every n seconds the cache is deleted,
                    regardless of usage. If None - cache will never be refreshed.

Notes           - If an instance method is wrapped, each instance will have it's own cache
                    and it's own timeout.
                - The wrapped function will have a cache_clear variable inserted
                    into it and may be called to clear it's specific cache.
                - The wrapped function will maintain the original function's
                    docstring and name (wraps)
                - The type of the wrapped function will no longer be that of a function
                    but either an instance of _LRU_Cache_class or a functools.partial type.

On Error        - No error handling is done, in case an exception is raised - it will permeate up.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lru_cache(maxsize=255, timeout=None):
    &#34;&#34;&#34;lru_cache(maxsize = 255, timeout = None) --&gt; returns a decorator which
    returns an instance (a descriptor).

        Purpose         - This decorator factory will wrap a function / instance method
                            and will supply a caching mechanism to the function.
                            For every given input params it will store the result in a queue
                            of maxsize size, and will return a cached ret_val
                            if the same parameters are passed.

        Params          - maxsize - int, the cache size limit, anything added above that will delete
                            the first values entered (FIFO).
                            This size is per instance, thus 1000 instances with maxsize of 255,
                            will contain at max 255K elements.
                        - timeout - int / float / None, every n seconds the cache is deleted,
                            regardless of usage. If None - cache will never be refreshed.

        Notes           - If an instance method is wrapped, each instance will have it&#39;s own cache
                            and it&#39;s own timeout.
                        - The wrapped function will have a cache_clear variable inserted
                            into it and may be called to clear it&#39;s specific cache.
                        - The wrapped function will maintain the original function&#39;s
                            docstring and name (wraps)
                        - The type of the wrapped function will no longer be that of a function
                            but either an instance of _LRU_Cache_class or a functools.partial type.

        On Error        - No error handling is done, in case an exception is raised - it will permeate up.
    &#34;&#34;&#34;

    class _LRU_Cache_class(object):
        # noinspection PyShadowingNames
        def __init__(self, input_func, max_size, timeout):
            self._input_func = input_func
            self._max_size = max_size
            self._timeout = timeout

            # This will store the cache for this function, format -
            # {caller1 : [OrderedDict1, last_refresh_time1], caller2 : [OrderedDict2, last_refresh_time2]}.
            #   In case of an instance method - the caller is the instance, in case called
            #   from a regular function - the caller is None.
            self._caches_dict = {}

        def cache_clear(self, caller=None):
            # Remove the cache for the caller, only if exists:
            if caller in self._caches_dict:
                del self._caches_dict[caller]
                self._caches_dict[caller] = [OrderedDict(), time.time()]

        def __get__(self, obj, obj_type):
            &#34;&#34;&#34; Called for instance methods &#34;&#34;&#34;
            return_func = functools.partial(self._cache_wrapper, obj)
            return_func.cache_clear = functools.partial(self.cache_clear, obj)
            # Return the wrapped function and wraps it to maintain the docstring and
            # the name of the original function:
            return functools.wraps(self._input_func)(return_func)

        def __call__(self, *args, **kwargs):
            &#34;&#34;&#34; Called for regular functions &#34;&#34;&#34;
            return self._cache_wrapper(None, *args, **kwargs)

        # Set the cache_clear function in the __call__ operator:
        __call__.cache_clear = cache_clear

        def _cache_wrapper(self, caller, *args, **kwargs):
            # Create a unique key including the types (in order to differentiate between 1 and &#39;1&#39;):
            kwargs_key = &#34;&#34;.join(map(lambda x: str(x) + str(type(kwargs[x])) + str(kwargs[x]), sorted(kwargs)))
            key = &#34;&#34;.join(map(lambda x: str(type(x)) + str(x), args)) + kwargs_key

            # Check if caller exists, if not create one:
            if caller not in self._caches_dict:
                self._caches_dict[caller] = [OrderedDict(), time.time()]
            else:
                # Validate in case the refresh time has passed:
                if self._timeout is not None:
                    if time.time() - self._caches_dict[caller][1] &gt; self._timeout:
                        self.cache_clear(caller)

            # Check if the key exists, if so - return it:
            cur_caller_cache_dict = self._caches_dict[caller][0]
            if key in cur_caller_cache_dict:
                return cur_caller_cache_dict[key]

            # Validate we didn&#39;t exceed the max_size:
            if len(cur_caller_cache_dict) &gt;= self._max_size:
                # Delete the first item in the dict:
                cur_caller_cache_dict.popitem(False)

            # Call the function and store the data in the cache (call it with
            # the caller in case it&#39;s an instance function - Ternary condition):
            cur_caller_cache_dict[key] = self._input_func(
                caller, *args, **kwargs) if caller is not None else self._input_func(
                *args, **kwargs
            )
            return cur_caller_cache_dict[key]

    # Return the decorator wrapping the class (also wraps the instance to
    # maintain the docstring and the name of the original function):
    return lambda input_func: functools.wraps(input_func)(_LRU_Cache_class(input_func, maxsize, timeout))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pywebcopy.helpers.CallbackFileWrapper"><code class="flex name class">
<span>class <span class="ident">CallbackFileWrapper</span></span>
<span>(</span><span>fp, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Small wrapper around a fp object which will tee everything read into a
buffer, and when that file is closed it will execute a callback with the
contents of that buffer.</p>
<p>All attributes are proxied to the underlying file object.</p>
<p>This class uses members with a double underscore (__) leading prefix so as
not to accidentally shadow an attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CallbackFileWrapper(object):
    &#34;&#34;&#34;
    Small wrapper around a fp object which will tee everything read into a
    buffer, and when that file is closed it will execute a callback with the
    contents of that buffer.

    All attributes are proxied to the underlying file object.

    This class uses members with a double underscore (__) leading prefix so as
    not to accidentally shadow an attribute.
    &#34;&#34;&#34;

    def __init__(self, fp, callback=None):
        self.__buf = BytesIO()
        self.__fp = fp
        self.__callback = callback
        self.__once_done = False

    def __getattr__(self, name):
        # The vagaries of garbage collection means that self.__fp is
        # not always set.  By using __getattribute__ and the private
        # name[0] allows looking up the attribute value and raising an
        # AttributeError when it doesn&#39;t exist. This stop things from
        # infinitely recurring calls to getattr in the case where
        # self.__fp hasn&#39;t been set.
        #
        # [0] https://docs.python.org/2/reference/expressions.html#atom-identifiers
        fp = self.__getattribute__(&#34;_CallbackFileWrapper__fp&#34;)
        return getattr(fp, name)

    def __is_fp_closed(self):
        try:
            return self.__fp.fp is None

        except AttributeError:
            pass

        try:
            return self.__fp.closed

        except AttributeError:
            pass

        return False

    def close(self):
        if self.__callback:
            # self.__callback(self.__buf.getvalue())
            self.__callback()

        # We assign this to None here, because otherwise we can get into
        # really tricky problems where the CPython interpreter dead locks
        # because the callback is holding a reference to something which
        # has a __del__ method. Setting this to None breaks the cycle
        # and allows the garbage collector to do it&#39;s thing normally.
        self.__callback = None
        self.__once_done = True
        return self.__getattribute__(&#34;_CallbackFileWrapper__fp&#34;).close()

    def rewind(self):
        if self.__once_done:
            self.__fp.close()
            self.__fp = self.__buf
            self.__buf = BytesIO()
            self.__fp.seek(0)
            self.__once_done = False

    def read(self, amt=None):
        data = self.__fp.read(amt)
        self.__buf.write(data)
        if self.__is_fp_closed():
            self.close()
        return data

    def _safe_read(self, amt):
        data = self.__fp._safe_read(amt)
        if amt == 2 and data == b&#34;\r\n&#34;:
            # urllib executes this read to toss the CRLF at the end
            # of the chunk.
            return data

        self.__buf.write(data)
        if self.__is_fp_closed():
            self.close()
        return data</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pywebcopy.helpers.CallbackFileWrapper.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    if self.__callback:
        # self.__callback(self.__buf.getvalue())
        self.__callback()

    # We assign this to None here, because otherwise we can get into
    # really tricky problems where the CPython interpreter dead locks
    # because the callback is holding a reference to something which
    # has a __del__ method. Setting this to None breaks the cycle
    # and allows the garbage collector to do it&#39;s thing normally.
    self.__callback = None
    self.__once_done = True
    return self.__getattribute__(&#34;_CallbackFileWrapper__fp&#34;).close()</code></pre>
</details>
</dd>
<dt id="pywebcopy.helpers.CallbackFileWrapper.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, amt=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, amt=None):
    data = self.__fp.read(amt)
    self.__buf.write(data)
    if self.__is_fp_closed():
        self.close()
    return data</code></pre>
</details>
</dd>
<dt id="pywebcopy.helpers.CallbackFileWrapper.rewind"><code class="name flex">
<span>def <span class="ident">rewind</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rewind(self):
    if self.__once_done:
        self.__fp.close()
        self.__fp = self.__buf
        self.__buf = BytesIO()
        self.__fp.seek(0)
        self.__once_done = False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pywebcopy.helpers.ConcurrentDelay"><code class="flex name class">
<span>class <span class="ident">ConcurrentDelay</span></span>
<span>(</span><span>timeout=0.1)</span>
</code></dt>
<dd>
<div class="desc"><p>Blocking waiter which calculates the delay irrespective of the
waiting call rather than just waiting on the specified time.</p>
<p>for example if time between two calls for delay are 10 seconds apart
but the timeout is set for 1 second then the second call will not block
but a successive third call will be blocked for 1 second before completing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConcurrentDelay(object):
    &#34;&#34;&#34;
    Blocking waiter which calculates the delay irrespective of the
    waiting call rather than just waiting on the specified time.

    for example if time between two calls for delay are 10 seconds apart
    but the timeout is set for 1 second then the second call will not block
    but a successive third call will be blocked for 1 second before completing.
    &#34;&#34;&#34;

    def __init__(self, timeout=1 / 10):
        self._timeout = None
        self.set_timeout(timeout)
        self.start_time = time.time()
        self._cond = threading.Condition()
        # self.logger = logger.getChild(self.__class__.__name__)

    def set_timeout(self, t):
        if not isinstance(t, (int, float)):
            raise ValueError(&#34;Expected int or float, got %r&#34; % t)
        if t &lt;= -1:
            raise ValueError(&#34;Delay cannot be smaller than 0&#34;)
        self._timeout = t

    def delay(self):
        &#34;&#34;&#34;Delays until the timeout is completed&#34;&#34;&#34;
        with self._cond:
            current_time = time.time()
            diff_time = current_time - self.start_time
            # prevent none type values from waiting infinitely
            if isinstance(self._timeout, (int, float)) \
                    and not diff_time &gt;= self._timeout:
                # self.logger.debug(
                # &#34;Waiting on request for [%r] seconds!&#34; % self._timeout)
                self._cond.wait(self._timeout - diff_time)
            self.start_time = current_time</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pywebcopy.helpers.ConcurrentDelay.delay"><code class="name flex">
<span>def <span class="ident">delay</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Delays until the timeout is completed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delay(self):
    &#34;&#34;&#34;Delays until the timeout is completed&#34;&#34;&#34;
    with self._cond:
        current_time = time.time()
        diff_time = current_time - self.start_time
        # prevent none type values from waiting infinitely
        if isinstance(self._timeout, (int, float)) \
                and not diff_time &gt;= self._timeout:
            # self.logger.debug(
            # &#34;Waiting on request for [%r] seconds!&#34; % self._timeout)
            self._cond.wait(self._timeout - diff_time)
        self.start_time = current_time</code></pre>
</details>
</dd>
<dt id="pywebcopy.helpers.ConcurrentDelay.set_timeout"><code class="name flex">
<span>def <span class="ident">set_timeout</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_timeout(self, t):
    if not isinstance(t, (int, float)):
        raise ValueError(&#34;Expected int or float, got %r&#34; % t)
    if t &lt;= -1:
        raise ValueError(&#34;Delay cannot be smaller than 0&#34;)
    self._timeout = t</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pywebcopy.helpers.RecentOrderedDict"><code class="flex name class">
<span>class <span class="ident">RecentOrderedDict</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A custom variant of the OrderedDict that ensures that the object most
recently inserted or retrieved from the dictionary is at the top of the
dictionary enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RecentOrderedDict(MutableMapping):
    &#34;&#34;&#34;
    A custom variant of the OrderedDict that ensures that the object most
    recently inserted or retrieved from the dictionary is at the top of the
    dictionary enumeration.
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        self._data = OrderedDict(*args, **kwargs)

    def __setitem__(self, key, value):
        if key in self._data:
            del self._data[key]
        self._data[key] = value

    def __getitem__(self, key):
        value = self._data[key]
        del self._data[key]
        self._data[key] = value
        return value

    def __delitem__(self, key):
        del self._data[key]

    def __iter__(self):
        return iter(self._data)

    def __len__(self):
        return len(self._data)

    def __contains__(self, value):
        return self._data.__contains__(value)

    def items(self):
        return self._data.items()

    def keys(self):
        return self._data.keys()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pywebcopy.schedulers.Index" href="schedulers.html#pywebcopy.schedulers.Index">Index</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywebcopy.helpers.RecentOrderedDict.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>D.items() -&gt; a set-like object providing a view on D's items</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self):
    return self._data.items()</code></pre>
</details>
</dd>
<dt id="pywebcopy.helpers.RecentOrderedDict.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>D.keys() -&gt; a set-like object providing a view on D's keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    return self._data.keys()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pywebcopy.helpers.RewindableResponse"><code class="flex name class">
<span>class <span class="ident">RewindableResponse</span></span>
<span>(</span><span>fp)</span>
</code></dt>
<dd>
<div class="desc"><p>Used by :class:<code>WebPage</code> to store current resource
content to minimize the number of requests made while
working with a page.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RewindableResponse(object):
    &#34;&#34;&#34;
    Used by :class:`WebPage` to store current resource
    content to minimize the number of requests made while
    working with a page.
    &#34;&#34;&#34;
    def __init__(self, fp):
        self.fp = fp
        self.buffer = BytesIO()
        self.once_done = threading.Event()

    def __getattr__(self, name):
        fp = self.__getattribute__(&#34;fp&#34;)
        return getattr(fp, name)

    @classmethod
    def from_response(cls, response):
        response.raw.decode_content = True
        ans = cls(response.raw)
        return ans

    def read(self, n=None):
        if self.fp.closed:
            self.once_done.set()
        data = self.fp.read(n)
        self.buffer.write(data)
        if self.fp.closed:
            self.once_done.set()
        return data

    def rewind(self):
        if not self.once_done.is_set():
            return False
        self.fp.close()
        self.buffer.seek(0)
        self.fp = self.buffer
        self.buffer = BytesIO()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pywebcopy.helpers.RewindableResponse.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_response(cls, response):
    response.raw.decode_content = True
    ans = cls(response.raw)
    return ans</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pywebcopy.helpers.RewindableResponse.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, n=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, n=None):
    if self.fp.closed:
        self.once_done.set()
    data = self.fp.read(n)
    self.buffer.write(data)
    if self.fp.closed:
        self.once_done.set()
    return data</code></pre>
</details>
</dd>
<dt id="pywebcopy.helpers.RewindableResponse.rewind"><code class="name flex">
<span>def <span class="ident">rewind</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rewind(self):
    if not self.once_done.is_set():
        return False
    self.fp.close()
    self.buffer.seek(0)
    self.fp = self.buffer
    self.buffer = BytesIO()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pywebcopy.helpers.cached_property"><code class="flex name class">
<span>class <span class="ident">cached_property</span></span>
<span>(</span><span>func, name=None, doc=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A decorator that converts a function into a lazy property.
The
function wrapped is called the first time to retrieve the result
and then that calculated result is used the next time you access
the value::</p>
<pre><code>class Foo(object):

    @cached_property
    def foo(self):
        # calculate something important here
        return 42
</code></pre>
<p>The class has to have a <code>__dict__</code> in order for this property to
work.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class cached_property(property):
    &#34;&#34;&#34;A decorator that converts a function into a lazy property.  The
    function wrapped is called the first time to retrieve the result
    and then that calculated result is used the next time you access
    the value::

        class Foo(object):

            @cached_property
            def foo(self):
                # calculate something important here
                return 42

    The class has to have a `__dict__` in order for this property to
    work.
    &#34;&#34;&#34;

    # implementation detail: A subclass of python&#39;s builtin property
    # decorator, we override __get__ to check for a cached value. If one
    # chooses to invoke __get__ by hand the property will still work as
    # expected because the lookup logic is replicated in __get__ for
    # manual invocation.

    # noinspection PyMissingConstructor
    def __init__(self, func, name=None, doc=None):
        self.__name__ = name or func.__name__
        self.__module__ = func.__module__
        self.__doc__ = doc or func.__doc__
        self.func = func

    def __set__(self, obj, value):
        obj.__dict__[self.__name__] = value

    def __get__(self, obj, *args, **kwargs):
        if obj is None:
            return self
        value = obj.__dict__.get(self.__name__, _missing)
        if value is _missing:
            value = self.func(obj)
            obj.__dict__[self.__name__] = value
        return value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.property</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pywebcopy" href="index.html">pywebcopy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pywebcopy.helpers.lru_cache" href="#pywebcopy.helpers.lru_cache">lru_cache</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pywebcopy.helpers.CallbackFileWrapper" href="#pywebcopy.helpers.CallbackFileWrapper">CallbackFileWrapper</a></code></h4>
<ul class="">
<li><code><a title="pywebcopy.helpers.CallbackFileWrapper.close" href="#pywebcopy.helpers.CallbackFileWrapper.close">close</a></code></li>
<li><code><a title="pywebcopy.helpers.CallbackFileWrapper.read" href="#pywebcopy.helpers.CallbackFileWrapper.read">read</a></code></li>
<li><code><a title="pywebcopy.helpers.CallbackFileWrapper.rewind" href="#pywebcopy.helpers.CallbackFileWrapper.rewind">rewind</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywebcopy.helpers.ConcurrentDelay" href="#pywebcopy.helpers.ConcurrentDelay">ConcurrentDelay</a></code></h4>
<ul class="">
<li><code><a title="pywebcopy.helpers.ConcurrentDelay.delay" href="#pywebcopy.helpers.ConcurrentDelay.delay">delay</a></code></li>
<li><code><a title="pywebcopy.helpers.ConcurrentDelay.set_timeout" href="#pywebcopy.helpers.ConcurrentDelay.set_timeout">set_timeout</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywebcopy.helpers.RecentOrderedDict" href="#pywebcopy.helpers.RecentOrderedDict">RecentOrderedDict</a></code></h4>
<ul class="">
<li><code><a title="pywebcopy.helpers.RecentOrderedDict.items" href="#pywebcopy.helpers.RecentOrderedDict.items">items</a></code></li>
<li><code><a title="pywebcopy.helpers.RecentOrderedDict.keys" href="#pywebcopy.helpers.RecentOrderedDict.keys">keys</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywebcopy.helpers.RewindableResponse" href="#pywebcopy.helpers.RewindableResponse">RewindableResponse</a></code></h4>
<ul class="">
<li><code><a title="pywebcopy.helpers.RewindableResponse.from_response" href="#pywebcopy.helpers.RewindableResponse.from_response">from_response</a></code></li>
<li><code><a title="pywebcopy.helpers.RewindableResponse.read" href="#pywebcopy.helpers.RewindableResponse.read">read</a></code></li>
<li><code><a title="pywebcopy.helpers.RewindableResponse.rewind" href="#pywebcopy.helpers.RewindableResponse.rewind">rewind</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywebcopy.helpers.cached_property" href="#pywebcopy.helpers.cached_property">cached_property</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>